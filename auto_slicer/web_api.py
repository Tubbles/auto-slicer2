"""HTTP API for the Telegram Mini App.

Provides endpoints for the Mini App to read the settings registry,
read/write per-user overrides, and apply presets. Uses aiohttp.

Authentication is via ephemeral Bearer tokens generated by the /webapp
bot command. Tokens have a 30-minute sliding TTL.
"""

import json
import secrets
import time

from aiohttp import web

from .config import Config
from .presets import load_presets
from .settings_eval import build_dep_graph, build_reverse_deps, evaluate_expressions
from .settings_registry import SettingDefinition
from .settings_validate import validate

TOKEN_TTL = 1800  # 30-minute sliding window
TOKEN_MAX_TTL = 86400  # 24-hour absolute maximum


def generate_token() -> str:
    """Generate a cryptographically random URL-safe token."""
    return secrets.token_urlsafe(32)


def validate_token(tokens: dict, token_str: str) -> int | None:
    """Validate a Bearer token. Returns user_id or None if invalid/expired."""
    entry = tokens.get(token_str)
    if entry is None:
        return None
    user_id, expiry, created = entry
    now = time.time()
    if now > expiry or now > created + TOKEN_MAX_TTL:
        del tokens[token_str]
        return None
    # Refresh sliding TTL (created stays the same)
    tokens[token_str] = (user_id, time.time() + TOKEN_TTL, created)
    return user_id


def cleanup_expired(tokens: dict) -> None:
    """Remove all expired tokens from the dict."""
    now = time.time()
    expired = [
        k for k, (_, expiry, created) in tokens.items()
        if now > expiry or now > created + TOKEN_MAX_TTL
    ]
    for k in expired:
        del tokens[k]


def _setting_to_dict(defn: SettingDefinition) -> dict:
    """Serialize a SettingDefinition to a JSON-friendly dict."""
    d = {
        "key": defn.key,
        "label": defn.label,
        "description": defn.description,
        "type": defn.setting_type,
        "default_value": defn.default_value,
        "category": defn.category,
    }
    if defn.unit:
        d["unit"] = defn.unit
    if defn.minimum_value is not None:
        d["minimum_value"] = defn.minimum_value
    if defn.maximum_value is not None:
        d["maximum_value"] = defn.maximum_value
    if defn.minimum_value_warning is not None:
        d["minimum_value_warning"] = defn.minimum_value_warning
    if defn.maximum_value_warning is not None:
        d["maximum_value_warning"] = defn.maximum_value_warning
    if defn.options:
        d["options"] = defn.options
    if defn.value_expression is not None:
        d["value_expression"] = defn.value_expression
    return d


def _build_registry_response(config: Config) -> dict:
    """Build the full registry response: settings grouped by category, presets, defaults."""
    all_settings = config.registry.all_settings()

    # Group settings by category
    categories: dict[str, list[dict]] = {}
    settings_list = []
    for key, defn in all_settings.items():
        sd = _setting_to_dict(defn)
        settings_list.append(sd)
        cat = defn.category or "Other"
        categories.setdefault(cat, []).append(sd)

    presets = load_presets()
    preset_data = {
        name: {"description": p["description"], "settings": p["settings"]}
        for name, p in presets.items()
    }

    dep_graph = build_dep_graph(config.registry)
    reverse = build_reverse_deps(dep_graph)
    # Convert sets to sorted lists for JSON serialization
    reverse_json = {k: sorted(v) for k, v in reverse.items()}

    return {
        "settings": settings_list,
        "categories": categories,
        "presets": preset_data,
        "defaults": config.defaults,
        "reverse_deps": reverse_json,
    }


def _validate_overrides(config: Config, overrides: dict[str, str]) -> dict:
    """Validate a batch of key:value pairs against the registry.

    Returns {"applied": {key: value}, "errors": {key: msg}, "warnings": {key: msg}}.
    """
    applied = {}
    errors = {}
    warnings = {}

    for key, raw_value in overrides.items():
        defn = config.registry.get(key)
        if not defn:
            errors[key] = f"Unknown setting: '{key}'"
            continue
        result = validate(defn, str(raw_value))
        if not result.ok:
            errors[key] = result.error
        else:
            applied[key] = result.coerced_value
            if result.warning:
                warnings[key] = result.warning

    return {"applied": applied, "errors": errors, "warnings": warnings}


async def handle_registry(request: web.Request) -> web.Response:
    """GET /api/registry — return the full settings registry."""
    config: Config = request.app["config"]

    # Use cached response if available
    cached = request.app.get("_registry_cache")
    if cached is None:
        cached = json.dumps(_build_registry_response(config))
        request.app["_registry_cache"] = cached

    return web.Response(text=cached, content_type="application/json")


async def handle_get_settings(request: web.Request) -> web.Response:
    """GET /api/settings — return current user overrides."""
    user_id = request["user_id"]
    user_settings: dict = request.app["user_settings"]
    overrides = user_settings.get(user_id, {})
    return web.json_response({"overrides": overrides})


async def handle_post_settings(request: web.Request) -> web.Response:
    """POST /api/settings — validate and apply user overrides.

    Body: {"overrides": {"key": "value", ...}, "remove": ["key", ...]}
    """
    user_id = request["user_id"]
    config: Config = request.app["config"]
    user_settings: dict = request.app["user_settings"]

    try:
        body = await request.json()
    except (json.JSONDecodeError, ValueError):
        return web.json_response({"error": "invalid JSON body"}, status=400)

    # Validate and apply overrides
    new_overrides = body.get("overrides", {})
    remove_keys = body.get("remove", [])

    result = _validate_overrides(config, new_overrides)

    # Apply valid settings
    if user_id not in user_settings:
        user_settings[user_id] = {}
    user_settings[user_id].update(result["applied"])

    # Remove requested keys
    for key in remove_keys:
        user_settings[user_id].pop(key, None)
    if not user_settings[user_id]:
        user_settings.pop(user_id, None)

    save_fn = request.app.get("save_fn")
    if save_fn:
        save_fn()

    return web.json_response(result)


async def handle_delete_settings(request: web.Request) -> web.Response:
    """DELETE /api/settings — clear all overrides for the authenticated user."""
    user_id = request["user_id"]
    user_settings: dict = request.app["user_settings"]
    user_settings.pop(user_id, None)

    save_fn = request.app.get("save_fn")
    if save_fn:
        save_fn()

    return web.json_response({"overrides": {}})


async def handle_get_starred(request: web.Request) -> web.Response:
    """GET /api/starred — return the current starred keys."""
    starred: set = request.app.get("starred_keys", set())
    return web.json_response({"keys": sorted(starred)})


async def handle_post_starred(request: web.Request) -> web.Response:
    """POST /api/starred — add/remove starred keys (auth required).

    Body: {"add": [...], "remove": [...]}
    """
    try:
        body = await request.json()
    except (json.JSONDecodeError, ValueError):
        return web.json_response({"error": "invalid JSON body"}, status=400)

    starred: set = request.app.get("starred_keys", set())
    starred.update(body.get("add", []))
    starred.difference_update(body.get("remove", []))

    save_fn = request.app.get("save_starred_fn")
    if save_fn:
        save_fn()

    return web.json_response({"keys": sorted(starred)})


async def handle_evaluate(request: web.Request) -> web.Response:
    """POST /api/evaluate — compute all expression-based settings.

    Body: {"overrides": {"key": "value", ...}}
    """
    config: Config = request.app["config"]

    try:
        body = await request.json()
    except (json.JSONDecodeError, ValueError):
        return web.json_response({"error": "invalid JSON body"}, status=400)

    pinned = body.get("overrides", {})
    result = evaluate_expressions(config.registry, pinned, config.defaults)

    return web.json_response({
        "computed": result.values,
        "errors": result.errors,
    })


async def handle_health(request: web.Request) -> web.Response:
    """GET /api/health — simple health check, no auth required."""
    return web.json_response({"status": "ok", "time": int(time.time())})


@web.middleware
async def auth_middleware(request: web.Request, handler) -> web.Response:
    """Validate Bearer token for all endpoints except health and OPTIONS."""
    if request.method == "OPTIONS" or request.path == "/api/health":
        return await handler(request)

    auth = request.headers.get("Authorization", "")
    if not auth.startswith("Bearer "):
        return web.json_response(
            {"error": "missing or invalid Authorization header"}, status=401,
        )

    token_str = auth[7:]
    tokens: dict = request.app["tokens"]
    user_id = validate_token(tokens, token_str)
    if user_id is None:
        return web.json_response({"error": "invalid or expired token"}, status=401)

    request["user_id"] = user_id
    return await handler(request)


@web.middleware
async def cors_middleware(request: web.Request, handler) -> web.Response:
    """Add CORS headers for the Mini App frontend."""
    if request.method == "OPTIONS":
        response = web.Response()
    else:
        response = await handler(request)

    allowed_origin = request.app.get("cors_origin", "*")
    response.headers["Access-Control-Allow-Origin"] = allowed_origin
    response.headers["Access-Control-Allow-Methods"] = "GET, POST, DELETE, OPTIONS"
    response.headers["Access-Control-Allow-Headers"] = "Authorization, Content-Type"
    return response


@web.middleware
async def logging_middleware(request: web.Request, handler) -> web.Response:
    """Log all incoming requests."""
    start = time.time()
    try:
        response = await handler(request)
        elapsed = (time.time() - start) * 1000
        print(f"[API] {request.method} {request.path} → {response.status} ({elapsed:.0f}ms)")
        return response
    except Exception as e:
        elapsed = (time.time() - start) * 1000
        print(f"[API] {request.method} {request.path} → ERROR: {e} ({elapsed:.0f}ms)")
        raise


def create_web_app(
    config: Config, user_settings: dict,
    cors_origin: str = "*", save_fn=None,
    starred_keys: set[str] | None = None, save_starred_fn=None,
    tokens: dict | None = None,
) -> web.Application:
    """Create and configure the aiohttp web application."""
    app = web.Application(middlewares=[logging_middleware, cors_middleware, auth_middleware])
    app["config"] = config
    app["user_settings"] = user_settings
    app["cors_origin"] = cors_origin
    app["tokens"] = tokens if tokens is not None else {}
    if save_fn:
        app["save_fn"] = save_fn
    if starred_keys is not None:
        app["starred_keys"] = starred_keys
    if save_starred_fn:
        app["save_starred_fn"] = save_starred_fn

    app.router.add_get("/api/health", handle_health)
    app.router.add_get("/api/registry", handle_registry)
    app.router.add_get("/api/settings", handle_get_settings)
    app.router.add_post("/api/settings", handle_post_settings)
    app.router.add_delete("/api/settings", handle_delete_settings)
    app.router.add_get("/api/starred", handle_get_starred)
    app.router.add_post("/api/starred", handle_post_starred)
    app.router.add_post("/api/evaluate", handle_evaluate)

    return app
